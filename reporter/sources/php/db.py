import json
import re

from reporter.helpers import generalize_sql, is_from_production_host
from reporter.reports import Report
from reporter.sources.php.common import PHPLogsSource


class DBQueryErrorsSource(PHPLogsSource):
    """ Get DB errors triggered by PHP application from elasticsearch """
    REPORT_LABEL = 'DBQueryErrors'

    FULL_MESSAGE_TEMPLATE = """
*Function*: {function}
*DB server*: {server}
*Error*: {error}

h3. Query
{{code:sql}}
{query}
{{code}}

h3. Message
{{code}}
{message}
{{code}}

h3. Backtrace
{backtrace}
"""

    # MySQL error codes
    # @see https://dev.mysql.com/doc/refman/5.5/en/error-messages-server.html
    ER_PARSE_ERROR = 1064
    ER_LOCK_WAIT_TIMEOUT = 1205
    ER_LOCK_DEADLOCK = 1213
    ER_QUERY_INTERRUPTED = 1317
    ER_CONNECTION_LOST = 2013

    def _get_entries(self, query):
        """ Return matching exception logs """
        return self._kibana.get_rows(match={"@exception.class": 'DBQueryError'}, limit=self.LIMIT)

    def _filter(self, entry):
        """ Remove log entries that are not coming from production datacenters """
        if not is_from_production_host(entry):
            return False

        context = entry.get('@context', {})

        # @context is expected to be an object below
        if type(context) is list:
            if len(context) > 0:
                self._logger.warning('Got a list as a @context: {}'.format(context))
            entry['@context'] = context = {}

        # get more context (e.g. function name) from the exception message generated by MW
        additional_context = self._get_context_from_entry(entry)
        if additional_context is not None:
            context.update(additional_context)

        # skip deadlocks (PLATFORM-1110)
        if context.get('errno') in [self.ER_LOCK_DEADLOCK, self.ER_LOCK_WAIT_TIMEOUT]:
            return False

        # filter out SMW and DPL errors
        if context.get('errno') in [self.ER_QUERY_INTERRUPTED, self.ER_CONNECTION_LOST] and \
                re.search(r'(SMW|DPLMain|SMWSQLStore2):', context.get('function', '')) is not None:
            return False

        return True

    def _normalize(self, entry):
        """
        Normalize given SQL error using normalized query and error code
        """
        context = self._get_context_from_entry(entry)

        if context is not None:
            query = context.get('query')

            if query is not None:
                # merge context coming from DB error reporting with
                # the one extracted from exception message (using self._get_context_from_entry)
                merged_context = entry.get('@context', {})
                merged_context.update(context)

                err_no = merged_context.get('errno')

                return '{}-{}'.format(
                    # PLATFORM-1512: normalize SQL parse errors (possibly SQL injection tries)
                    # using function name instead of a normalized query
                    merged_context.get('function') if err_no == self.ER_PARSE_ERROR else generalize_sql(query),
                    err_no
                )

        return None

    def _get_kibana_url(self, entry):
        """
        Get the link to Kibana dashboard showing the provided error log entry
        """
        context = entry.get('@context')

        return self.format_kibana_url(
            query='@exception.class: "DBQueryError" AND @exception.message: "{}"'.format(context.get('function')),
            columns=['@timestamp', '@source_host', '@context.errno', '@context.err', '@fields.db_name', '@fields.http_url']
        )

    def _get_report(self, entry):
        """ Format the report to be sent to JIRA """
        context = entry.get('@context')

        query = context.get('query')
        normalized = generalize_sql(query)

        # remove server IP from error message
        error_no_ip = context.get('error').\
            replace('({})'.format(context.get('server')), '').\
            strip()

        # format the report
        full_message = self.FULL_MESSAGE_TEMPLATE.format(
            message=entry.get('@message', '').strip(),
            query=query,
            error=error_no_ip,
            function=context.get('function'),
            server=context.get('server'),
            backtrace=self._get_backtrace_from_exception(entry.get('@exception'))
        ).strip()

        description = self.REPORT_TEMPLATE.format(
            env=self._get_env_from_entry(entry),
            source_host=entry.get('@source_host', 'n/a'),
            context_formatted=json.dumps(entry.get('@context', {}), indent=True),
            fields_formatted=json.dumps(entry.get('@fields', {}), indent=True),
            full_message=full_message,
            url=self._get_url_from_entry(entry) or 'n/a'
        ).strip()

        return Report(
            summary='[DB error {err}] {function} - {query}'.format(
                err=error_no_ip, function=context.get('function'), query=normalized),
            description=description,
            label=self.REPORT_LABEL
        )

    @staticmethod
    def _get_context_from_entry(entry):
        """ Parse message coming from MediaWiki and extract key information """
        exception = entry.get('@exception', {})
        context = entry.get('@context', {})
        message = exception.get('message')

        if message is None:
            return None

        message = message.strip()

        """
        A database error has occurred.  Did you forget to run maintenance/update.php after upgrading?  See: https://www.mediawiki.org/wiki/Manual:Upgrading#Run_the_update_script
        Query: SELECT  DISTINCT `page`.page_namespace AS page_namespace,`page`.page_title AS page_title,`page`.page_id AS page_id, `page`.page_title  as sortkey FROM `page` WHERE 1=1  AND `page`.page_namespace IN ('6') AND `page`.page_is_redirect=0 AND 'Hal Homsar Solo' = (SELECT rev_user_text FROM `revision` WHERE `revision`.rev_page=page_id ORDER BY `revision`.rev_timestamp ASC LIMIT 1) ORDER BY page_title ASC LIMIT 0, 500
        Function: DPLMain:dynamicPageList
        Error: 1317 Query execution was interrupted (10.8.38.37)
        """

        # parse multiline message
        parsed = dict()

        for line in message.split("\n")[1:]:
            if ':' in line:
                [key, value] = line.split(":", 1)
                parsed[key] = value.strip()

        # normalize "DatabaseBase::sourceFile( /usr/wikia/slot1/3690/src/maintenance/cleanupStarter.sql )"
        func = parsed.get('Function', '')
        func = re.sub(r'/usr/wikia/slot1/\d+/src', '', func)

        err_str = context.get('err', '')
        err_str = err_str if err_str else ''

        context = {
            'query': parsed.get('Query'),
            'function': func,
            'error': '{} {}'.format(context.get('errno'), err_str),
        }

        return context


class DBQueriesLogsSource(PHPLogsSource):
    # use dedicated SQL logs index
    ELASTICSEARCH_INDEX_PREFIX = 'logstash-mediawiki-sql'

    def _get_entries(self, query):
        """ This method will query the source and return matching entries """
        raise NotImplementedError("_get_entries() method needs to be overwritten in your class!")

    def _filter(self, entry):
        """ Callback used to filter entries """
        raise NotImplementedError("_filter() method needs to be overwritten in your class!")

    def _normalize(self, entry):
        """
        Normalize given message by removing variables like server name
        to improve grouping of messages
        """
        raise NotImplementedError("_normalize() method needs to be overwritten in your class!")

    def _get_report(self, entry):
        """
        Return a report for a given entry

        :type entry object
        :rtype: reporter.reports.Report
        """
        raise NotImplementedError("_get_report() method needs to be overwritten in your class!")


class DBQueryNoLimitSource(DBQueriesLogsSource):
    """ Get DB queries that return excessive number of rows """
    REPORT_LABEL = 'DBQueryNoLimit'

    ROWS_THRESHOLD = 2000

    FULL_MESSAGE_TEMPLATE = """
The database query below returned far too many rows. Please use a proper LIMIT statement.

*Query*: {{noformat}}{query}{{noformat}}
*Function*: {function}
*Rows returned*: {num_rows}

h5. Backtrace
* {backtrace}
"""

    # use dedicated SQL logs index
    ELASTICSEARCH_INDEX_PREFIX = 'logstash-mediawiki-sql'

    def _get_entries(self, query):
        """ Return matching exception logs """
        # @see http://www.solrtutorial.com/solr-query-syntax.html
        return self._kibana.query_by_string(
            query='@context.num_rows: [{} TO *]'.format(self.ROWS_THRESHOLD),
            limit=self.LIMIT
        )

    def _filter(self, entry):
        if not is_from_production_host(entry):
            return False

        # remove those that do not return enough rows
        context = entry.get('@context', dict())
        if context.get('num_rows', 0) < self.ROWS_THRESHOLD:
            return False

        return True

    def _normalize(self, entry):
        """ Normalize the entry using the query and the method that made it """
        message = entry.get('@message')
        context = entry.get('@context', dict())

        return '{}-{}-no-limit'.format(generalize_sql(message), context.get('method'))

    def _get_report(self, entry):
        """ Format the report to be sent to JIRA """
        context = entry.get('@context')

        query = entry.get('@message').strip()

        # format the report
        full_message = self.FULL_MESSAGE_TEMPLATE.format(
            query=query,
            function=context.get('method'),
            num_rows=context.get('num_rows'),
            backtrace=self._get_backtrace_from_exception(entry.get('@exception'))
        ).strip()

        description = self.REPORT_TEMPLATE.format(
            env=self._get_env_from_entry(entry),
            source_host=entry.get('@source_host', 'n/a'),
            context_formatted=json.dumps(entry.get('@context', {}), indent=True),
            fields_formatted=json.dumps(entry.get('@fields', {}), indent=True),
            full_message=full_message,
            url=self._get_url_from_entry(entry) or 'n/a'
        ).strip()

        return Report(
            summary='[{method}] The database query returns {rows}k+ rows'.format(
                method=context.get('method'), rows=context.get('num_rows') / 1000),
            description=description,
            label=self.REPORT_LABEL
        )


class DBReadQueryOnMaster(DBQueriesLogsSource):
    """ Get DB queries that were made on master node when they should be performed on slaves"""
    REPORT_LABEL = 'DBMasterQueryOnGET'

    FULL_MESSAGE_TEMPLATE = """
The database query below was performed on master node when handling GET request.
Refactor the code to use database slaves or move it to an offline task.

h3. Query
{{code:sql}}
{query}
{{code}}

*Function*: {function}
*DB server*: {server}

h5. Backtrace
{backtrace}
"""

    # use dedicated SQL logs index
    ELASTICSEARCH_INDEX_PREFIX = 'logstash-mediawiki-sql'

    def _get_entries(self, query):
        """ Return matching logs """
        # @see https://kibana5.wikia-inc.com/goto/df410efc54de95bcb68a0d327539cb61
        return self._kibana.query_by_string(
            query='@context.server: "geo-db-sharedb-master.query.consul" AND '
                  '@fields.http_method: "GET" AND '
                  '@fields.environment: "prod" AND '
                  '@fields.datacenter: "sjc"',
            limit=self.LIMIT
        )

    def _filter(self, entry):
        """ Ignore transaction control queries """
        query = entry.get('@message')
        if query.startswith('BEGIN ') or query.startswith('COMMIT '):
            return False

        return True

    def _normalize(self, entry):
        """ Normalize the entry """
        method = entry.get('@context').get('method')
        return '{}'.format(method)

    def _get_report(self, entry):
        """ Format the report to be sent to JIRA """
        context = entry.get('@context')

        query = entry.get('@message').strip()

        # format the report
        full_message = self.FULL_MESSAGE_TEMPLATE.format(
            query=query,
            function=context.get('method'),
            server=context.get('server'),
            backtrace=self._get_backtrace_from_exception(entry.get('@exception'))
        ).strip()

        report = Report(
            summary='[{method}] The database query should be moved to slave or an offline task'.format(
                method=context.get('method')),
            description=full_message,
            label=self.REPORT_LABEL
        )

        report.add_label('active-active')
        report.add_label('database')

        return report

    def _get_kibana_url(self, entry):
        """
        Get the link to Kibana dashboard showing the provided error log entry
        """
        context = entry.get('@context')

        return self.format_kibana_url(
            query='@context.method: "{}"'.format(context.get('method')),
            columns=['@message', '@context.db_name', '@context.server', '@fields.http_method', '@fields.http_url'],
            index='logstash-mediawiki-sql'
        )
